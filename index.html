<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Epistellaire — Livre numérique</title>
  <meta name="description" content="Feuilletez l’univers d’Epistellaire : un livre numérique pensé comme une œuvre d’art immersive." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Playfair+Display:wght@500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://unpkg.com/page-flip/dist/css/page-flip.min.css" />
  <style>
    :root {
      color-scheme: only light;
      --bg: #f9f6f2;
      --bg-accent: #f1ede6;
      --text-primary: #2f2538;
      --text-secondary: rgba(47, 37, 56, 0.68);
      --accent: #b48fbf;
      --accent-strong: #9d7bb5;
      --surface: rgba(255, 255, 255, 0.92);
      --surface-stroke: rgba(182, 164, 198, 0.28);
      --shadow: 0 28px 72px rgba(110, 98, 132, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      color: var(--text-primary);
      background: radial-gradient(circle at top, rgba(255, 255, 255, 0.92) 0%, rgba(237, 232, 223, 0.88) 35%, var(--bg) 100%);
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }

    body::before {
      content: "";
      position: fixed;
      inset: -20%;
      pointer-events: none;
      background: radial-gradient(circle at 25% 15%, rgba(192, 177, 202, 0.4), transparent 55%),
        radial-gradient(circle at 80% 10%, rgba(184, 203, 213, 0.32), transparent 50%),
        radial-gradient(circle at 50% 100%, rgba(173, 152, 185, 0.32), transparent 60%);
      filter: blur(18px);
      opacity: 0.65;
      z-index: 0;
    }

    .page-shell {
      min-height: 100vh;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: clamp(24px, 6vw, 80px);
      gap: clamp(24px, 5vw, 48px);
      z-index: 1;
    }

    .page-shell > *:not(.particle-layer) {
      position: relative;
      z-index: 2;
    }

    .particle-layer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 1;
      mix-blend-mode: screen;
    }

    .particle-layer .particle {
      position: absolute;
      width: var(--size, 3px);
      height: var(--size, 3px);
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 0 12px rgba(200, 210, 220, 0.75);
      opacity: 0;
      animation: floatParticle var(--duration, 12s) linear infinite;
      animation-delay: var(--delay, 0s);
    }

    @keyframes floatParticle {
      0% {
        transform: translate3d(0, 40vh, 0) scale(0.8);
        opacity: 0;
      }
      20% {
        opacity: 0.35;
      }
      50% {
        opacity: 0.5;
      }
      100% {
        transform: translate3d(0, -60vh, 0) scale(1.2);
        opacity: 0;
      }
    }

    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(32px, 6vw, 72px);
      width: min(1180px, 100%);
    }

    .intro {
      text-align: center;
      max-width: 540px;
      background: rgba(255, 255, 255, 0.55);
      border-radius: 32px;
      padding: clamp(18px, 4vw, 32px);
      border: 1px solid rgba(186, 168, 200, 0.32);
      box-shadow: 0 18px 48px rgba(110, 98, 132, 0.12);
      backdrop-filter: blur(14px);
    }

    .intro h1 {
      margin: 0 0 14px;
      font-family: "Playfair Display", "Times New Roman", serif;
      font-size: clamp(2.1rem, 5vw, 3.4rem);
      line-height: 1.08;
      letter-spacing: 0.05em;
      font-weight: 500;
    }

    .intro p {
      margin: 0 0 1.1rem;
      color: var(--text-secondary);
      font-size: clamp(1rem, 1.4vw, 1.18rem);
      line-height: 1.7;
    }

    .immersive-invite {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      background: rgba(189, 176, 205, 0.22);
      color: var(--text-primary);
      letter-spacing: 0.16em;
      text-transform: uppercase;
      font-size: 0.75rem;
    }

    .viewer {
      width: min(100%, 960px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .book-frame {
      position: relative;
      width: 100%;
      padding: clamp(20px, 3vw, 28px);
      border-radius: 34px;
      background: linear-gradient(170deg, rgba(255, 255, 255, 0.92), rgba(239, 236, 244, 0.72));
      border: 1px solid rgba(189, 171, 205, 0.32);
      box-shadow: 0 38px 80px rgba(110, 98, 132, 0.24);
      backdrop-filter: blur(18px);
      overflow: hidden;
    }

    #book {
      width: 100%;
      height: min(70vh, 680px);
      margin: 0 auto;
      border-radius: 20px;
      overflow: hidden;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .native-book-viewport {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .native-book-stage {
      position: relative;
      width: min(100%, 960px);
      height: 100%;
      aspect-ratio: 3 / 2;
      max-height: 100%;
      transform: scale(var(--book-scale, 1));
      transform-origin: center;
      transition: transform 220ms ease;
      perspective: 1600px;
      cursor: pointer;
      touch-action: pan-y;
    }

    .turnjs-viewport {
      position: relative;
      width: min(100%, 960px);
      height: min(70vh, 620px);
      transform: scale(var(--book-scale, 1));
      transform-origin: center;
      transition: transform 220ms ease;
      cursor: pointer;
      touch-action: pan-y;
    }

    .turnjs-viewport::before {
      content: "";
      position: absolute;
      inset: 12% -8% -6%;
      border-radius: 26px;
      background: radial-gradient(
        circle at center,
        rgba(143, 126, 158, 0.28),
        rgba(143, 126, 158, 0)
      );
      transform: translateZ(-1px);
      filter: blur(18px);
      opacity: 0.75;
      pointer-events: none;
    }

    .turnjs-stage {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 28px 50px rgba(110, 98, 132, 0.18);
      background: linear-gradient(160deg, #fdfbf7 0%, #f4f0ea 100%);
    }

    .turnjs-page {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      background: #fdfbf7;
    }

    .turnjs-page img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #fdfbf7;
    }

    .native-book-stage::before {
      content: "";
      position: absolute;
      inset: 12% -8% -6%;
      border-radius: 26px;
      background: radial-gradient(
        circle at center,
        rgba(143, 126, 158, 0.28),
        rgba(143, 126, 158, 0)
      );
      transform: translateZ(-1px);
      filter: blur(18px);
      opacity: 0.75;
    }

    .native-sheet {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      border-radius: 18px;
      overflow: hidden;
      background: linear-gradient(160deg, #fdfbf7 0%, #f4f0ea 100%);
      box-shadow: 0 28px 50px rgba(110, 98, 132, 0.18);
      transform-style: preserve-3d;
      backface-visibility: hidden;
      pointer-events: none;
    }

    .native-sheet img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #fdfbf7;
    }

    .native-sheet__shine {
      position: absolute;
      inset: 0;
      background: linear-gradient(
        115deg,
        rgba(255, 255, 255, 0.38) 0%,
        rgba(255, 255, 255, 0) 42%,
        rgba(120, 110, 143, 0.08) 100%
      );
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .native-sheet--standby {
      opacity: 0;
    }

    .native-sheet--current {
      opacity: 1;
      pointer-events: auto;
    }

    .native-sheet--flip-forward,
    .native-sheet--reveal-forward {
      transform-origin: left center;
      animation-duration: 0.85s;
      animation-timing-function: cubic-bezier(0.77, 0, 0.175, 1);
      animation-fill-mode: forwards;
    }

    .native-sheet--flip-backward,
    .native-sheet--reveal-backward {
      transform-origin: right center;
      animation-duration: 0.85s;
      animation-timing-function: cubic-bezier(0.77, 0, 0.175, 1);
      animation-fill-mode: forwards;
    }

    .native-sheet--flip-forward {
      animation-name: nativeFlipForward;
      z-index: 3;
    }

    .native-sheet--reveal-forward {
      animation-name: nativeRevealForward;
      z-index: 2;
    }

    .native-sheet--flip-backward {
      animation-name: nativeFlipBackward;
      z-index: 3;
    }

    .native-sheet--reveal-backward {
      animation-name: nativeRevealBackward;
      z-index: 2;
    }

    @keyframes nativeFlipForward {
      0% {
        transform: rotateY(0deg);
        opacity: 1;
      }
      100% {
        transform: rotateY(-180deg);
        opacity: 0.2;
      }
    }

    @keyframes nativeRevealForward {
      0% {
        transform: rotateY(180deg);
        opacity: 0.1;
      }
      100% {
        transform: rotateY(0deg);
        opacity: 1;
      }
    }

    @keyframes nativeFlipBackward {
      0% {
        transform: rotateY(0deg);
        opacity: 1;
      }
      100% {
        transform: rotateY(180deg);
        opacity: 0.2;
      }
    }

    @keyframes nativeRevealBackward {
      0% {
        transform: rotateY(-180deg);
        opacity: 0.1;
      }
      100% {
        transform: rotateY(0deg);
        opacity: 1;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .native-sheet--flip-forward,
      .native-sheet--reveal-forward,
      .native-sheet--flip-backward,
      .native-sheet--reveal-backward {
        animation-duration: 0.01ms !important;
      }
    }

    .page {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fdfbf7;
    }

    .page img,
    .page iframe,
    .page svg {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    }

    .page-indicator {
      position: absolute;
      bottom: clamp(80px, 12vw, 120px);
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 0.85rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(47, 37, 56, 0.58);
      background: rgba(255, 255, 255, 0.5);
      padding: 0.5rem 1rem;
      border-radius: 999px;
      backdrop-filter: blur(12px);
    }

    .controls {
      position: absolute;
      bottom: clamp(24px, 5vw, 48px);
      left: 50%;
      transform: translateX(-50%);
      display: inline-flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.78);
      border: 1px solid rgba(182, 164, 198, 0.35);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 36px rgba(110, 98, 132, 0.18);
    }

    .controls button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.55rem 0.95rem;
      background: linear-gradient(135deg, rgba(201, 188, 214, 0.34), rgba(204, 221, 229, 0.38));
      color: var(--text-primary);
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 180ms ease, background 180ms ease, box-shadow 180ms ease;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 8px 18px rgba(120, 110, 143, 0.18);
    }

    .controls button:hover,
    .controls button:focus-visible {
      transform: translateY(-1px);
      outline: none;
      background: linear-gradient(135deg, rgba(201, 188, 214, 0.48), rgba(204, 221, 229, 0.48));
    }

    .controls button:active {
      transform: translateY(0);
    }

    .sound-toggle {
      position: absolute;
      top: clamp(18px, 3vw, 28px);
      right: clamp(18px, 3vw, 28px);
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      background: rgba(255, 255, 255, 0.65);
      color: var(--text-primary);
      letter-spacing: 0.16em;
      text-transform: uppercase;
      font-size: 0.68rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease, box-shadow 160ms ease;
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 24px rgba(110, 98, 132, 0.18);
    }

    .sound-toggle:hover,
    .sound-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.85);
      transform: translateY(-1px);
      outline: none;
    }

    .sound-toggle[data-state="on"] {
      background: rgba(181, 199, 210, 0.58);
      box-shadow: 0 12px 26px rgba(110, 98, 132, 0.22);
    }

    .sound-toggle:focus-visible {
      box-shadow: 0 0 0 3px rgba(153, 138, 173, 0.36);
    }

    footer {
      max-width: 540px;
      text-align: center;
      color: rgba(47, 37, 56, 0.55);
      font-size: 0.9rem;
      line-height: 1.6;
      margin: clamp(16px, 4vw, 48px) 0 0;
    }

    footer strong {
      font-weight: 600;
    }

    @media (max-width: 840px) {
      .book-frame {
        border-radius: 28px;
      }

      .controls {
        position: static;
        transform: none;
        margin-top: 18px;
        box-shadow: 0 12px 28px rgba(110, 98, 132, 0.2);
      }

      .page-indicator {
        position: static;
        transform: none;
        margin-top: 12px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .particle-layer {
        display: none;
      }
    }

    @media (max-width: 640px) {
      .page-shell {
        padding: 32px 24px 48px;
      }

      .intro {
        padding: 22px;
      }

      #book {
        height: min(64vh, 540px);
      }
    }
  </style>
</head>
<body>
  <div class="page-shell">
    <div class="particle-layer" aria-hidden="true"></div>

    <main>
      <section class="intro">
        <p class="immersive-invite">Epistellaire — carnet vivant</p>
        <h1>Laissez le livre respirer, contemplez chaque page.</h1>
        <p>
          Prenez place face à l’œuvre : l’espace disparaît, ne restent que les textures et les pigments.
          Explorez au rythme des pages, en vous laissant guider par la lumière.
        </p>
        <p>
          Un souffle discret enveloppe votre lecture. Utilisez les flèches du clavier ou les commandes pour feuilleter,
          et revenez lorsque l’artiste ajoute une nouvelle création.
        </p>
      </section>

      <section class="viewer" aria-label="Visionneuse du livre">
        <div class="book-frame">
          <button type="button" class="sound-toggle" data-sound-toggle aria-pressed="false" aria-label="Activer ou couper l’ambiance sonore">Ambiance sonore</button>
          <div id="book" aria-live="polite" aria-label="Livre d’artiste"></div>
          <p class="page-indicator" id="pageIndicator">Préparation du livre…</p>
          <div class="controls" role="toolbar" aria-label="Contrôles du livre">
            <button type="button" data-action="first">Première</button>
            <button type="button" data-action="prev">Précédente</button>
            <button type="button" data-action="next">Suivante</button>
            <button type="button" data-action="last">Dernière</button>
            <button type="button" data-action="zoomIn">Zoom +</button>
            <button type="button" data-action="zoomOut">Zoom −</button>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <p>
        <strong>Astuce&nbsp;:</strong> ouvrez le livre en plein écran pour un tête-à-tête prolongé et laissez-le vivant&nbsp;:
        la dernière page se métamorphose au fil des nouvelles œuvres.
      </p>
    </footer>
  </div>

  <script type="application/json" id="pagesData">
    [
      {
        "src": "assets/pages/001.jpg",
        "title": "Couverture"
      },
      {
        "src": "assets/pages/002.jpg",
        "title": "Jour 1"
      },
      {
        "src": "assets/pages/003.svg",
        "title": "Jour 2"
      }
    ]
  </script>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/turn.js@4/turn.min.js"></script>
  <script src="https://unpkg.com/page-flip/dist/js/page-flip.browser.min.js"></script>
  <script>
    (function () {
      const bookEl = document.getElementById('book');
      const pageIndicator = document.getElementById('pageIndicator');
      const soundToggle = document.querySelector('[data-sound-toggle]');
      const particleLayer = document.querySelector('.particle-layer');
      const qs = new URLSearchParams(location.search);
      const startAtLast = qs.get('last') !== '0';

      const motionQuery =
        typeof window.matchMedia === 'function'
          ? window.matchMedia('(prefers-reduced-motion: reduce)')
          : null;
      let isReducedMotion = motionQuery?.matches ?? false;

      const spawnParticles = () => {
        if (!particleLayer || isReducedMotion) return;
        particleLayer.innerHTML = '';
        const baseCount = window.innerWidth < 640 ? 28 : window.innerWidth < 1024 ? 40 : 56;
        for (let i = 0; i < baseCount; i++) {
          const node = document.createElement('span');
          node.className = 'particle';
          const size = (Math.random() * 3 + 1.5).toFixed(2);
          node.style.setProperty('--size', `${size}px`);
          node.style.left = `${(Math.random() * 100).toFixed(2)}%`;
          node.style.setProperty('--duration', `${(Math.random() * 10 + 12).toFixed(2)}s`);
          node.style.setProperty('--delay', `${(-Math.random() * 20).toFixed(2)}s`);
          particleLayer.appendChild(node);
        }
      };

      motionQuery?.addEventListener?.('change', (event) => {
        isReducedMotion = event.matches;
        if (isReducedMotion) {
          particleLayer?.replaceChildren?.();
        } else {
          spawnParticles();
        }
      });

      let resizeTimeout;
      addEventListener('resize', () => {
        if (!particleLayer || isReducedMotion) return;
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(spawnParticles, 240);
      });

      const ambientSound = (() => {
        let context;
        let gainNode;
        let source;
        let active = false;

        const buildTextureBuffer = (ctx) => {
          const bufferSize = 2 * ctx.sampleRate;
          const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          let lastOut = 0;
          for (let i = 0; i < bufferSize; i += 1) {
            const white = Math.random() * 2 - 1;
            lastOut = (lastOut + 0.02 * white) / 1.02;
            data[i] = lastOut * 0.55;
          }
          return buffer;
        };

        const start = () => {
          if (active) return true;
          const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextCtor) {
            console.warn("L'API Web Audio n'est pas disponible sur ce navigateur.");
            return false;
          }

          try {
            context = new AudioContextCtor();
            const buffer = buildTextureBuffer(context);
            source = context.createBufferSource();
            source.buffer = buffer;
            source.loop = true;
            gainNode = context.createGain();
            gainNode.gain.setValueAtTime(0, context.currentTime);
            source.connect(gainNode);
            gainNode.connect(context.destination);
            source.start();
            gainNode.gain.linearRampToValueAtTime(0.08, context.currentTime + 1.6);
            active = true;
            return true;
          } catch (error) {
            console.warn("Impossible d’activer l’ambiance sonore.", error);
            context = undefined;
            gainNode = undefined;
            source = undefined;
            active = false;
            return false;
          }
        };

        const stop = () => {
          if (!active) return false;
          active = false;
          if (context && gainNode) {
            try {
              gainNode.gain.cancelScheduledValues(context.currentTime);
              gainNode.gain.linearRampToValueAtTime(0, context.currentTime + 0.6);
            } catch (error) {
              console.warn('Impossible de lisser le volume lors de la coupure.', error);
            }
          }

          const finalize = () => {
            try {
              source?.stop?.();
            } catch (error) {
              console.warn('Interruption de la source audio.', error);
            }
            if (context) {
              context.close().catch(() => {});
            }
            context = undefined;
            gainNode = undefined;
            source = undefined;
          };

          setTimeout(finalize, 650);
          return false;
        };

        const toggle = () => {
          if (active) {
            return stop();
          }
          return start();
        };

        const isActive = () => active;

        return { start, stop, toggle, isActive };
      })();

      const updateSoundToggle = () => {
        if (!soundToggle) return;
        const active = ambientSound.isActive();
        soundToggle.setAttribute('aria-pressed', active ? 'true' : 'false');
        soundToggle.dataset.state = active ? 'on' : 'off';
        soundToggle.textContent = active ? 'Ambiance activée' : 'Ambiance sonore';
      };

      const attemptAutoAmbient = () => {
        if (ambientSound.isActive()) return;
        const started = ambientSound.start();
        if (started) {
          updateSoundToggle();
        }
      };

      soundToggle?.addEventListener('click', (event) => {
        event.stopPropagation();
        ambientSound.toggle();
        updateSoundToggle();
      });

      let resumeOnVisible = false;
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          resumeOnVisible = ambientSound.isActive();
          if (resumeOnVisible) {
            ambientSound.stop();
            updateSoundToggle();
          }
        } else if (resumeOnVisible) {
          attemptAutoAmbient();
          resumeOnVisible = false;
        }
      });

      const handleFirstInteraction = () => {
        attemptAutoAmbient();
        updateSoundToggle();
      };

      document.addEventListener(
        'pointerdown',
        () => {
          handleFirstInteraction();
        },
        { once: true },
      );

      addEventListener('keydown', (event) => {
        if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
          handleFirstInteraction();
        }
      });

      spawnParticles();
      updateSoundToggle();

      const inlinePages = (() => {
        const el = document.getElementById('pagesData');
        if (!el) return null;
        try {
          return JSON.parse(el.textContent);
        } catch (error) {
          console.warn('Impossible de lire les pages intégrées.', error);
          return null;
        }
      })();

      const loadPages = () => {
        if (location.protocol === 'file:' && inlinePages) {
          return Promise.resolve(inlinePages);
        }

        return fetch('pages.json', { cache: 'no-store' })
          .then((r) => {
            if (!r.ok) {
              throw new Error(`Réponse inattendue du manifest (${r.status})`);
            }
            return r.json();
          })
          .catch((err) => {
            if (inlinePages && inlinePages.length) {
              console.warn(
                'Utilisation des pages intégrées faute de chargement du manifest distant.',
                err,
              );
              return inlinePages;
            }
            throw err;
          });
      };

      const updateIndicator = (current, total, title) => {
        const label = title ? ` — ${title}` : '';
        pageIndicator.textContent = `Page ${current} / ${total}${label}`;
      };

      loadPages()
        .then((pages) => {
          if (!Array.isArray(pages) || pages.length === 0) {
            throw new Error('Aucune page à afficher.');
          }

          const bindControls = (actions) => {
            document.querySelectorAll('[data-action]').forEach((button) => {
              const action = actions[button.dataset.action];
              if (typeof action === 'function') {
                button.addEventListener('click', action);
              }
            });
          };

          const bindKeyboard = (actions) => {
            addEventListener('keydown', (e) => {
              if (e.key === 'ArrowLeft') actions.prev?.();
              if (e.key === 'ArrowRight') actions.next?.();
              if (e.key === '+') actions.zoomIn?.();
              if (e.key === '-' || e.key === '–') actions.zoomOut?.();
            });
          };

          let preferredAspectRatio = 0.62;

          const calibrateAspectRatio = (metaList, onUpdate) => {
            const candidate = metaList.find((meta) => typeof meta?.src === 'string');
            if (!candidate) {
              return;
            }

            const probe = new Image();
            probe.decoding = 'async';
            probe.src = candidate.src;

            const update = () => {
              if (!probe.naturalWidth || !probe.naturalHeight) {
                return;
              }
              const ratio = probe.naturalHeight / probe.naturalWidth;
              if (!ratio || Number.isNaN(ratio)) {
                return;
              }
              const clamped = Math.max(0.45, Math.min(1.1, Number(ratio.toFixed(3))));
              if (Math.abs(clamped - preferredAspectRatio) > 0.01) {
                preferredAspectRatio = clamped;
                onUpdate?.();
              }
            };

            if (probe.complete) {
              update();
            } else {
              probe.addEventListener('load', update, { once: true });
            }
          };

          const computeStageSize = () => {
            const rect = bookEl.getBoundingClientRect();
            const containerWidth = rect.width || bookEl.clientWidth || 720;
            const width = Math.max(360, Math.min(960, Math.round(containerWidth)));
            const height = Math.round(width * preferredAspectRatio);
            return { width, height };
          };

          const setupResizeListener = (callback) => {
            let ticking = false;
            const handler = () => {
              if (ticking) return;
              ticking = true;
              requestAnimationFrame(() => {
                ticking = false;
                callback();
              });
            };
            addEventListener('resize', handler);
            return () => removeEventListener('resize', handler);
          };

          const setupWithTurnJs = () => {
            const $ = window.jQuery;
            if (!$ || typeof $.fn?.turn !== 'function') {
              return false;
            }

            bookEl.innerHTML = '';

            const viewport = document.createElement('div');
            viewport.className = 'turnjs-viewport';
            viewport.style.setProperty('--book-scale', '1');

            const stage = document.createElement('div');
            stage.className = 'turnjs-stage';
            viewport.appendChild(stage);
            bookEl.appendChild(viewport);

            pages.forEach((meta) => {
              const page = document.createElement('div');
              page.className = 'turnjs-page page';
              const img = document.createElement('img');
              img.decoding = 'async';
              img.loading = 'lazy';
              img.draggable = false;
              img.src = meta.src;
              img.alt = meta.title || '';
              page.appendChild(img);
              stage.appendChild(page);
            });

            const initialSize = computeStageSize();
            viewport.style.width = `${initialSize.width}px`;
            viewport.style.height = `${initialSize.height}px`;

            const $stage = $(stage);
            $stage.turn({
              width: initialSize.width,
              height: initialSize.height,
              display: 'single',
              autoCenter: true,
              duration: 1100,
              gradients: true,
              elevation: 70,
            });

            const applySize = () => {
              const { width, height } = computeStageSize();
              viewport.style.width = `${width}px`;
              viewport.style.height = `${height}px`;
              $stage.turn('size', width, height);
            };

            setupResizeListener(applySize);
            calibrateAspectRatio(pages, applySize);

            let currentScale = 1;
            const applyScale = () => {
              viewport.style.setProperty('--book-scale', currentScale.toFixed(3));
            };
            applyScale();

            const syncIndicator = (pageNumber) => {
              const safePage = Math.max(1, Math.min(pages.length, pageNumber));
              const meta = pages[safePage - 1] || {};
              updateIndicator(safePage, pages.length, meta.title);
            };

            $stage.on('turned', (_event, pageNumber) => {
              syncIndicator(pageNumber);
            });

            const actions = {
              first: () => $stage.turn('page', 1),
              prev: () => $stage.turn('previous'),
              next: () => $stage.turn('next'),
              last: () => $stage.turn('page', pages.length),
              zoomIn: () => {
                currentScale = Math.min(currentScale + 0.12, 1.7);
                applyScale();
              },
              zoomOut: () => {
                currentScale = Math.max(currentScale - 0.12, 0.7);
                applyScale();
              },
            };

            viewport.addEventListener('click', (event) => {
              const rect = viewport.getBoundingClientRect();
              const isLeft = event.clientX - rect.left < rect.width / 2;
              if (isLeft) {
                actions.prev();
              } else {
                actions.next();
              }
            });

            bindControls(actions);
            bindKeyboard(actions);

            requestAnimationFrame(() => {
              const initialPage = startAtLast ? pages.length : 1;
              $stage.turn('page', initialPage);
              syncIndicator(initialPage);
            });

            return true;
          };

          const setupWithPageFlip = () => {
            const baseSize = computeStageSize();
            const book = new window.PageFlip(bookEl, {
              width: baseSize.width,
              height: baseSize.height,
              size: 'stretch',
              showCover: true,
              useMouseEvents: true,
              maxShadowOpacity: 0.18,
              mobileScrollSupport: true,
            });

            const htmlContainer = document.createElement('div');

            pages.forEach((p) => {
              const el = document.createElement('div');
              el.className = 'page';
              const img = document.createElement('img');
              img.src = p.src;
              img.alt = p.title || '';
              el.appendChild(img);
              htmlContainer.appendChild(el);
            });

            book.loadFromHTML(htmlContainer.children);

            let sizeMultiplier = 1;

            const applySize = () => {
              const { width, height } = computeStageSize();
              const scaledWidth = Math.round(width * sizeMultiplier);
              const scaledHeight = Math.round(height * sizeMultiplier);
              book.update({ width: scaledWidth, height: scaledHeight });
            };

            applySize();
            setupResizeListener(applySize);
            calibrateAspectRatio(pages, applySize);

            const actions = {
              first: () => book.flip(0),
              prev: () => book.flipPrev(),
              next: () => book.flipNext(),
              last: () => book.flip(book.getPageCount() - 1),
              zoomIn: () => {
                sizeMultiplier = Math.min(sizeMultiplier + 0.12, 1.7);
                applySize();
              },
              zoomOut: () => {
                sizeMultiplier = Math.max(sizeMultiplier - 0.12, 0.7);
                applySize();
              },
            };

            const getCurrentIndex = () => {
              if (typeof book.getCurrentPageIndex === 'function') {
                return book.getCurrentPageIndex();
              }
              if (typeof book.getCurrentPage === 'function') {
                return book.getCurrentPage();
              }
              return 0;
            };

            const syncIndicator = (pageIndex) => {
              const total = book.getPageCount();
              if (!total) {
                pageIndicator.textContent = 'Aucune page disponible pour le moment.';
                return;
              }
              const safeIndex = Math.max(0, Math.min(total - 1, pageIndex));
              const current = safeIndex + 1;
              const meta = pages[safeIndex] || {};
              updateIndicator(current, total, meta.title);
            };

            book.on('flip', (e) => {
              syncIndicator(e.data);
            });

            bindControls(actions);
            bindKeyboard(actions);

            requestAnimationFrame(() => {
              if (startAtLast) {
                const lastIndex = Math.max(0, book.getPageCount() - 1);
                book.flip(lastIndex);
                syncIndicator(lastIndex);
              } else {
                syncIndicator(getCurrentIndex());
              }
            });
          };

          const setupFallback = () => {
            console.warn(
              'La bibliothèque PageFlip est indisponible. Activation du feuilletage natif.',
            );
            bookEl.innerHTML = '';

            const clampIndex = (value) => Math.max(0, Math.min(pages.length - 1, value));

            const viewport = document.createElement('div');
            viewport.className = 'native-book-viewport';

            const stage = document.createElement('div');
            stage.className = 'native-book-stage';
            stage.style.setProperty('--book-scale', '1');

            const createSheet = (name) => {
              const el = document.createElement('figure');
              el.className = `native-sheet native-sheet--${name} native-sheet--standby`;
              el.setAttribute('aria-hidden', 'true');

              const img = document.createElement('img');
              img.decoding = 'async';
              img.loading = 'lazy';
              el.appendChild(img);

              const shine = document.createElement('div');
              shine.className = 'native-sheet__shine';
              el.appendChild(shine);

              return { el, img };
            };

            let currentSheet = createSheet('current');
            let standbySheet = createSheet('standby');

            stage.append(currentSheet.el, standbySheet.el);
            viewport.append(stage);
            bookEl.appendChild(viewport);

            const applyStageSize = () => {
              const { width, height } = computeStageSize();
              viewport.style.width = `${width}px`;
              viewport.style.height = `${height}px`;
              stage.style.width = `${width}px`;
              stage.style.height = `${height}px`;
            };

            applyStageSize();
            setupResizeListener(applyStageSize);
            calibrateAspectRatio(pages, applyStageSize);

            let currentIndex = clampIndex(startAtLast ? pages.length - 1 : 0);
            let currentScale = 1;
            let isFlipping = false;
            const prefersReducedMotion = isReducedMotion;

            const preloaded = new Set();

            const preloadAround = (index) => {
              [index - 1, index + 1].forEach((i) => {
                const meta = pages[clampIndex(i)];
                if (!meta || meta === pages[index] || preloaded.has(meta.src)) return;
                preloaded.add(meta.src);
                const img = new Image();
                img.src = meta.src;
              });
            };

            const updateSheet = (sheet, meta) => {
              if (!meta) {
                sheet.el.classList.add('native-sheet--standby');
                sheet.el.classList.remove('native-sheet--current');
                sheet.el.setAttribute('aria-hidden', 'true');
                sheet.img.removeAttribute('src');
                sheet.img.alt = '';
                return;
              }

              sheet.el.classList.remove('native-sheet--standby');
              sheet.el.classList.remove('native-sheet--current');
              sheet.el.setAttribute('aria-hidden', 'false');
              sheet.img.src = meta.src;
              sheet.img.alt = meta.title || '';
            };

            const applyScale = () => {
              stage.style.setProperty('--book-scale', currentScale.toFixed(3));
            };

            const syncState = () => {
              const meta = pages[currentIndex];
              updateSheet(currentSheet, meta);
              currentSheet.el.classList.add('native-sheet--current');
              currentSheet.el.setAttribute('aria-hidden', 'false');
              updateSheet(standbySheet, null);
              updateIndicator(currentIndex + 1, pages.length, meta?.title);
              applyScale();
              preloadAround(currentIndex);
            };

            const flipTo = (targetIndex) => {
              const safeTarget = clampIndex(targetIndex);
              if (safeTarget === currentIndex || isFlipping) {
                return;
              }

              if (prefersReducedMotion) {
                currentIndex = safeTarget;
                syncState();
                return;
              }

              const direction = safeTarget > currentIndex ? 'forward' : 'backward';
              isFlipping = true;

              const revealClass =
                direction === 'forward'
                  ? 'native-sheet--reveal-forward'
                  : 'native-sheet--reveal-backward';
              const flipClass =
                direction === 'forward'
                  ? 'native-sheet--flip-forward'
                  : 'native-sheet--flip-backward';

              updateSheet(standbySheet, pages[safeTarget]);
              standbySheet.el.classList.remove('native-sheet--current');
              standbySheet.el.classList.remove('native-sheet--standby');
              standbySheet.el.classList.add(revealClass);

              currentSheet.el.classList.remove('native-sheet--current');
              currentSheet.el.classList.add(flipClass);

              let finished = 0;
              const handleAnimationEnd = (event) => {
                if (event.target !== event.currentTarget) return;
                finished += 1;
                if (finished < 2) return;

                currentSheet.el.classList.remove(flipClass);
                currentSheet.el.classList.add('native-sheet--standby');
                currentSheet.el.setAttribute('aria-hidden', 'true');

                standbySheet.el.classList.remove(revealClass);
                standbySheet.el.classList.add('native-sheet--current');

                currentSheet.el.removeEventListener('animationend', handleAnimationEnd);
                standbySheet.el.removeEventListener('animationend', handleAnimationEnd);

                const temp = currentSheet;
                currentSheet = standbySheet;
                standbySheet = temp;

                currentIndex = safeTarget;
                updateIndicator(currentIndex + 1, pages.length, pages[currentIndex]?.title);
                updateSheet(standbySheet, null);
                preloadAround(currentIndex);

                isFlipping = false;
              };

              currentSheet.el.addEventListener('animationend', handleAnimationEnd);
              standbySheet.el.addEventListener('animationend', handleAnimationEnd);

              // force reflow to allow animation to trigger consistently
              void standbySheet.el.offsetWidth;
            };

            const actions = {
              first: () => flipTo(0),
              prev: () => flipTo(currentIndex - 1),
              next: () => flipTo(currentIndex + 1),
              last: () => flipTo(pages.length - 1),
              zoomIn: () => {
                currentScale = Math.min(currentScale + 0.12, 1.7);
                applyScale();
              },
              zoomOut: () => {
                currentScale = Math.max(currentScale - 0.12, 0.7);
                applyScale();
              },
            };

            stage.addEventListener('click', (event) => {
              const rect = stage.getBoundingClientRect();
              const isLeft = event.clientX - rect.left < rect.width / 2;
              if (isLeft) {
                actions.prev();
              } else {
                actions.next();
              }
            });

            bindControls(actions);
            bindKeyboard(actions);
            syncState();
          };

          if (setupWithTurnJs()) {
            return;
          }

          if (typeof window.PageFlip === 'function') {
            setupWithPageFlip();
            return;
          }

          setupFallback();
        })
        .catch((err) => {
          pageIndicator.textContent = 'Les pages seront bientôt disponibles.';
          bookEl.innerHTML =
            '<p style="padding:1rem; text-align:center; color: rgba(47, 37, 56, 0.7)">La collection est en cours de préparation.</p>';
          console.error(err);
        });
    })();
  </script>
</body>
</html>
